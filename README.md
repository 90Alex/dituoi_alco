# Αλγόριθμοι και πολυπλοκότητα

Γκόγκος Χρήστος @ Τμήμα Πληροφορικής και Τηλεπικοινωνιών, Άρτα, Πανεπιστήμιο Ιωαννίνων

Τελευταία ενημέρωση: 13/11/2021


## 1. Ανάλυση αλγορίθμων


## 5. Ουρές προτεραιότητας και σωροί

* [Οπτικοποίηση](https://www.cs.usfca.edu/~galles/visualization/Heap.html) δημιουργίας σωρού ελαχίστων (MINHEAP) με διαδοχικές εισαγωγές τιμών: π.χ. χρησιμοποιήστε το πλήκτρο **Insert** για τη διαδοχική εισαγωγή των τιμών 21,5,17,12,3,9,16 σε έναν σωρό ελαχίστων
* [Οπτικοποίηση](https://www.cs.usfca.edu/~galles/visualization/Heap.html) δημιουργίας σωρού ελαχίστων (MINHEAP) με τη διαδικασία heapify: χρησιμοποιήστε το πλήκτρο **BuildHeap** για τη δημιουργία ενός σωρού ελαχίστων από έναν πίνακα 31 τιμών με τους ακέραιους από 1 μέχρι και 31
* [Οπτικοποίηση](http://btv.melezinek.cz/binary-heap.html) λειτουργιών insert, delete, heapsort, buildheap σε σωρό μεγίστων (MAXHEAP) 

**Ουρές προτεραιότητας στην Python**

[heapq](https://docs.python.org/3/library/heapq.html)

Παράδειγμα: [heapq_example.py](./heapq_example.py)

**Ουρές προτεραιότητας στην C++**

[std::priority_queue](https://en.cppreference.com/w/cpp/container/priority_queue)

Παράδειγμα: [priority_queue_example.cpp](./priority_queue_example.cpp)

**Ουρές προτεραιότητας στην Java**

[PriorityQueue\<E\>](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/PriorityQueue.html)

Παραδείγματα: [Java PriorityQueue by Programiz](https://www.programiz.com/java-programming/priorityqueue)

**Ασκήσεις**
  
1. Έστω ένας μηχανισμός παραγωγής πραγματικών τιμών. Όταν παράγεται μια νέα τιμή να υπολογίζεται και να εμφανίζεται η διάμεσος από όλες τις τιμές που έχουν παραχθεί μέχρι εκείνη τη χρονική στιγμή. Γράψτε πρόγραμμα που να υλοποιεί τη λύση.
   * Σημείωση 1: η διάμεσος μιας λίστας παρατηρήσεων είναι η τιμή της μεσαίας παρατήρησης στη διατεταγμένη σε αύξουσα σειρά λίστας παρατηρήσεων όταν το πλήθος των παρατηρήσεων είναι περιττό, και το ημιάθροισμα των δύο μεσαίων παρατηρήσεων στη διατεταγμένη σε αύξουσα σειρά λίστας παρατηρήσεων όταν όταν το πλήθος των παρατηρήσεων είναι άρτιο. 
   * Σημείωση 2: Προσομοιώστε την παραγωγή πραγματικών τιμών με μια λίστα  τυχαίων πραγματικών τιμών. Θεωρείστε ότι στη χρονική στιγμή 0 παράγεται η τιμή που βρίσκεται στη θέση 0 της λίστας, στη χρονική στιγμή 1 παράγεται η τιμή που βρίσκεται στη θέση 1 της λίστας κ.ο.κ. 

    <!-- * [heap_exercise2.py](./heap_exercise2.py) -->

    ```
    Περιγραφή αλγοριθμικής προσέγγισης

    Δημιουργούνται δύο σωροί, ένας σωρός μεγίστων (ΜΑΧHEAP) και ένας σωρός ελαχίστων (MINHEAP). Η ρίζα του MAXHEAP θα πρέπει να είναι μικρότερη από τη ρίζα του MINHEAP. Αν αυτό δεν ισχύει θα πρέπει να μεταφέρεται η ρίζα του ενός από τους δύο σωρούς στον άλλο σωρό έτσι ώστε να επιβληθεί αυτή η συνθήκη. Οι εισαγωγές νέων τιμών θα γίνονται πάντα στον MAXHEAP. Οι δύο σωροί θα πρέπει να έχουν το ίδιο μέγεθος ή ο ένας να είναι κατά 1 μόνο στοιχείο μεγαλύτερος του άλλου και όταν αυτό παραβιάζεται θα μεταφέρεται η ρίζα του μεγαλύτερου σωρού στον μικρότερο σωρό. Η διάμεσος θα είναι είτε η ρίζα του μεγαλύτερου σωρού είτε το ημιάθροισμα των ριζών των δύο σωρών.

    # Ψευδοκώδικας 
    1. Λήψη νέου ακεραίου και προσθήκη στον MAXHEAP
    2. Αν η ρίζα του MAXHEAP είναι μεγαλύτερη από τη ρίζα του MINHEAP τότε αφαίρεσε τη ρίζα του MAXHEAP και πρόσθεσέ την στον MINHEAP
    3. Αν το μέγεθος των 2 σωρών διαφέρει κατά 2 αφαίρεσε τη ρίζα από το μεγαλύτερο σωρό και πρόσθεσε την στο μικρότερο σωρό.
    4. Η διάμεσος θα είναι o μέσος όρος των κορυφών των 2 σωρών, αν οι σωροί έχουν το ίδιο μέγεθος ή η ρίζα του μεγαλύτερου από τους 2 σωρούς.
    5. Επιστροφή στο βήμα 1 ή τερματισμός

## 6. Χάρτες    

Οι χάρτες (maps), ή χάρτες κατακερματισμού (hashmaps) ή λεξικά (dictionaries) ή συσχετιστικοί πίνακες (associative arrays) ή συσχετιστικές μνήμες (associative memories) είναι σύνολα ζευγών κλειδί/τιμή. Υποστηρίζουν τις λειτουργίες εντοπισμού (με δεδομένο το κλειδί), εισαγωγής του ζεύγους κλειδί/τιμή΄και διαγραφής (με δεδομένο το κλειδί) με υψηλή ταχύτητα, Ο(1) υπό προϋποθέσεις.

**Λεξικά στην Python**

[dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries), [υλοποίηση των dictionaries στην Python](https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented)

Παράδειγμα: [dictionary_example.py](./dictionary_example.py) 

**Μη διατεταγμένοι χάρτες στην C++**

[unordered_map](https://en.cppreference.com/w/cpp/container/unordered_map)

Παράδειγμα: [unordered_map_example.cpp](./unordered_map_example.cpp)

**Χάρτες κατακερματισμού στην Java**

[HashMap](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/HashMap.html)


### Συναρτήσεις κατακερματισμού

**Κρυπτογραφικές συναρτήσεις κατακερματισμού**

* [SHA256 Hash by Blockchain Demo](https://andersbrownworth.com/blockchain/hash)
* [SlavaSoft HashCalc](https://www.slavasoft.com/hashcalc/)

**Παραδείγματα με hash functions στην Python**

* [interactive_py_hash.py](./interactive_py_hash.py)
* [interactive_py_hash2.py](./interactive_py_hash2.py) κρυπτογραφικες συναρτήσεις κατακερματσιμού με το module hashlib

**Μη κρυπτογραφικές συναρτήσεις κατακερματισμού (χρήση σε δομές δεδομένων)**

* [General Purpose Hash Function Algorithms](http://www.partow.net/programming/hashfunctions/index.html#AvailableHashFunctions)
* [djb2, sdbm](http://www.cse.yorku.ca/~oz/hash.html)
* [FNV](http://www.isthe.com/chongo/tech/comp/fnv/)
* [murmur](https://www.sderosiaux.com/articles/2017/08/26/the-murmur3-hash-function--hashtables-bloom-filters-hyperloglog/)

**Ελάχιστη τέλεια συηνάρτηση κατακερματισμού (minimal perfect hash function)**

Τέλεια συνάρτηση κατακερματισμού είναι συνάρτηση κατακερματισμού η οποία αντιστοιχίζει τα στοιχεία ενός συνόλου σε ένα σύνολο ακεραίων χωρίς συγκρούσεις. Ελάχιστη τέλεια συνάρτηση κατακερματισμού είναι μια τέλεια συνάρτηση κατακερματισμού που αντιστοιχίζει χωρίς συγκρούσεις n κλειδιά σε n διαδοχικούς ακεραίους από το 0 έως το n-1.

Δείτε και το [http://cmph.sourceforge.net/concepts.html](http://cmph.sourceforge.net/concepts.html)

### Ανοικτή διευθυνσιοδότηση (open addressing) 

Η ανοικτή διευνσιοδότηση λαμβάνει το όνομά της από την ιδιότητα που έχει να επιτρέπει στα κλειδιά να μετακινηθούν και σε άλλες θέσεις διαφορετικές από τη θέση στην οποία γίνονται αρχικά hash. 

Η ανοικτή διευνσιοδότηση είναι γνωστή και ως κλειστός κατακερματισμός (closed hashing) καθώς τα κλειδία τοποθετούνται μόνο εντός του πίνακα κατακερματισμού και δεν χρησιμοποιείται κάποια άλλη βοηθητική δομή. 

* [Οπτικοποίηση](https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html) ανοικτής διευθυνσιοδότησης

**Παραλλαγές ανοικτής διευθυνσιοδότησης**

* Γραμμική ανίχνευση (linear probing)
* Τετραγωνική ανίχνευση (quadratic probing)
* Διπλός κατακερματισμός (double hashing)
* Τυχαίος κατακερματισμός (random hashing)

### Κλειστή διευθυνσιοδότηση (closed addressing)

Η κλειστή διευνσιοδότηση λαμβάνει το όνομά της από την ιδιότητα που έχει να τοποθετεί τα κλειδιά στη θέση στην οποία γίνονται hash, χρησιμοποιώντας μια βοηθητική δομή (π.χ. συνδεδεμένη λίστα) για να αποθηκεύσει στην ίδια θέση πιθανώς περισσότερα από ένα στοιχεία τα οποία γίνονται hash στην ίδια θέση. 

Η κλειστή διευθυνσιοδότηση είναι γνωστή και ως ανοικτός κατακερματισμός (open hashing) και ως ξεχωριστή αλυσίδωση (separate chaining). Το όνομα ανοικτός κατακερματισμός προκύπτει καθώς τα κλειδιά δεν είναι απαραίτητο να βρίσκονται εντός του ίδιου του πίνακα κατακερματισμού, αλλά μπορούν να βρίσκονται σε κάποια βοηθητική δομή.

* [Οπτικοποίηση](https://www.cs.usfca.edu/~galles/visualization/OpenHash.html) κλειστής διευθυνσιοδότησης

### Κατακερματισμός κούκου

* [Οπτικοποίηση](https://www.lkozma.net/cuckoo_hashing_visualization/) κατακερματισμού κούκου.

**Ασκήσεις**

1. Γράψτε ένα πρόγραμμα που να δέχεται έναν πίνακα ακεραίων και μια τιμή sum και να εμφανίζει όλα τα ζεύγη τιμών του πίνακα με άθροισμα ίσο με την τιμή sum.
    <!-- * [hash_exercise1.py](./hash_exercise1.py) -->
2. Γράψτε ένα πρόγραμμα που να εντοπίζει σε ένα λεξικό με μεγάλο πλήθος λέξεων όλες τις λέξεις για τις οποίες υπάρχουν τουλάχιστον άλλες 4 λέξεις που είναι αναγραμματισμοί της (π.χ. user -> ['rues', 'ruse', 'suer', 'sure', 'user']).
    <!-- * [hash_exercise2.py](./hash_exercise2.py) -->
3. Γράψτε ένα προγραμμα που να εντοπίζει το πλήθος των διακριτών ακεραίων σε μια μεγάλη λίστα ακεραίων.
   <!-- * [hash_exercise3.py](./hash_exercise3.py) -->

## Συνδυαστικές ασκήσεις

1. Δίνεται μια ακολουθία μεγάλου μεγέθους με τυχαίες ακέραιες τιμές. Ζητείται να βρεθούν οι 10 πλέον συχνές τιμές χρησιμοποιώντας μια ουρά προτεραιότητας. Αναζητήστε την αποδοτικότερη λύση. Γράψτε πρόγραμμα που να υλοποιεί τη λύση.
   
<!-- * [heap_exercise1a.py](./heap_exercise1a.py)
* [heap_exercise1b.py](./heap_exercise1b.py) -->
